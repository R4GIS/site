---
title: "Chamada pra briga - Competição Kaggle Guess The Correlation"
date: "2018-03-29"
tags: ["kaggle", "deep learning"]
categories: ["divulgação"]
banner: "img/banners/guess-the-correlation.jpg"
author: ["Athos"]
summary: "Criamos uma competição no Kaggle para aprender a máquina adivinhar a correlação de um scatterplot. Desafio lançado!"
---

Alô alôww Comunidade

Lançamos [uma competição Kaggle](https://www.kaggle.com/c/guess-the-correlation/) e agora é a hora de você mostrar que é Jedi em DATA SCIENCE! =D

Link: [https://www.kaggle.com/c/guess-the-correlation/](https://www.kaggle.com/c/guess-the-correlation/)

A gente fez isso por esporte, favor não tentar achar utilidade nessa aplicação =P.

## O Jogo

O site [Guess The Correlation](http://guessthecorrelation.com/) coloca o ser humano frente a frente com um gráfico de dispersão, em que este é em seguida desafiado a adivinhar respectiva a correlação linear. 

No nosso desafio Kaggle, desafio similar foi construído. Foram geradas 200 mil imagens em png como as abaixo:

<center>
![](/img/blog/2018-03-29-guess-the-correlation/exemplo_img.png)
</center>

e cada uma dessas imagens tem a sua correleção anotada para treinarmos um modelinho.

## Objetivo

O objetivo é simples e direto: construir um robô que calcula a correlação (linear) apenas vendo o gráfico de dispersão.

Em *machine lârnês*, queremos

<center>
![](/img/blog/2018-03-29-guess-the-correlation/f_img_92.png)
</center>

em que essa **f** seja digna de ser **f** de **F@!#**.

## Chute inicial

O [Julião](https://github.com/jtrecenti) já andou trabalhando nesse problema e deu um chute inicial nos códigos pra vocês se inspirarem. Aliás, "inicial" numas, porque ele já saiu fazendo um CNN com a ajuda do pacote [decryptr](https://github.com/decryptr/decryptr): 

```{r eval=FALSE}
library(keras)
library(tidyverse)
library(decryptr)

path <- "./"

arqs <- dir(paste0(path,  "/train_imgs"), full.names = TRUE)
resp <- readr::read_csv(paste0(path,  "/train_responses.csv"))

set.seed(4747)
i_train <- sample(1:nrow(resp), 10000)
d_train <- resp[i_train,] %>% 
  arrange(id)
d_test <- resp[-i_train,] %>% 
  arrange(id)

nm_files <- arqs %>% 
  basename() %>% 
  tools::file_path_sans_ext()

nm_files_train <- nm_files[tolower(nm_files) %in% d_train$id]
nm_files_test <- nm_files[tolower(nm_files) %in% d_test$id]

nm_files_train_complete <- stringr::str_glue("{path}/train_imgs/{nm_files_train}.png")
imgs <- decryptr::read_captcha(nm_files_train_complete)

# Check whether frac_test is less than or equal to 100%

# Convert list of captchas to expected format
captchas_t <- purrr::transpose(imgs)
xs <- captchas_t$x
xs <- abind::abind(xs, along = 0.1)
data <- list(n = length(imgs), y = d_train$corr, x = xs)
n_units <- 1000
# Get absolute numbers
n_tot <- data$n

# Create model
model <- keras_model_sequential()
model %>%
  layer_conv_2d(
    input_shape = dim(data$x)[-1],
    filters = 16, kernel_size = c(5, 5),
    padding = "same",
    activation = "relu") %>%
  layer_max_pooling_2d() %>%
  layer_conv_2d(
    filters = 32, kernel_size = c(5, 5),
    padding = "same",
    activation = "relu") %>%
  layer_max_pooling_2d() %>%
  layer_conv_2d(
    filters = 64, kernel_size = c(5, 5),
    padding = "same",
    activation = "relu") %>%
  layer_max_pooling_2d() %>%
  layer_flatten() %>%
  layer_dense(units = 100) %>%
  layer_dropout(.1) %>%
  layer_dense(units = 1, activation = "tanh")


# Compile and fit model
model %>%
  compile(
    optimizer = "sgd",
    loss = "mean_squared_error",
    metrics = "accuracy")

model %>%
  fit(
    x = data$x,
    y = data$y,
    batch_size = 100,
    epochs = 10,
    shuffle = TRUE,
    validation_data = list(data$x, data$y)
  )
```


E aí? Será que dá pra acertar 100%? Ou será impossível?

Boa R'ada!
