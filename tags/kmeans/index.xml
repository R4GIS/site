<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kmeans on Curso-R</title>
    <link>http://curso-r.com/tags/kmeans/index.xml</link>
    <description>Recent content in Kmeans on Curso-R</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <copyright>Copyright (c) 2016 - 2017, Curso-R; all rights reserved.</copyright>
    <atom:link href="http://curso-r.com/tags/kmeans/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Gráficos miojo: Mapas temáticos do Brasil em 3 minutos ou menos</title>
      <link>http://curso-r.com/blog/2017/05/04/2017-05-04-mapas-tematicos-3-minutos/</link>
      <pubDate>Thu, 04 May 2017 23:26:00 +0300</pubDate>
      
      <guid>http://curso-r.com/blog/2017/05/04/2017-05-04-mapas-tematicos-3-minutos/</guid>
      <description>&lt;p&gt;De todas as visualizações, mapas são aquelas que impressionam mais. É muito mais fácil alguém se maravilhar com o mapa mais simples do que com o &lt;code&gt;ggplot2&lt;/code&gt; mais complicado. Felizmente, considerando essa comparação, o R disponibiliza muitos recursos para construir mapas. É possível fazer mapas interativos ou estáticos com simplicidade.&lt;/p&gt;
&lt;p&gt;Dentro do &lt;code&gt;tidyverse&lt;/code&gt; é possível construir mapas usando a função &lt;code&gt;geom_map&lt;/code&gt;, do pacote &lt;code&gt;ggplot2&lt;/code&gt;. Está fora do escopo deste post explicar como ela funciona, mas vamos descobrir como usá-la para agilizar a construção de um gráfico simples.&lt;/p&gt;
&lt;p&gt;Na Associação Brasileira de Jurimetria, nós temos um tipo favorito de mapa. Tipicamente temos interesse em diferenciar as unidades da federação por alguma variável quantitativa, seja ela categorizada ou não, e a ferramenta certa para isso é um mapa temático dos estados. Essa necessidade é tão frequente que as ferramentas mais importantes para construção desses gráficos estão num pacote chamado &lt;code&gt;abjData&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As coisas estão dispostas de tal forma que, a partir de uma tabela que relaciona uma variavel e os estados brasileiros, construir um gráfico similar ao mapa abaixo pode ser feito chamando apenas uma função[^FBSP].&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dataset %&amp;gt;% 
  constroi_mapa_tematico()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-05-04-mapas-tematicos-3-minutos_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Neste post, vamos construir a função &lt;code&gt;constroi_mapa_tematico&lt;/code&gt; e aprender a implementar alguns &lt;code&gt;tweaks&lt;/code&gt;.&lt;/p&gt;
&lt;div id=&#34;a-funcao&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;A função&lt;/h2&gt;
&lt;p&gt;O &lt;code&gt;geom_map&lt;/code&gt; é uma função do &lt;code&gt;ggplot2&lt;/code&gt; que renderiza coordenadas de mapas. Ela pega um data_frame especial que diz quais coordenadas usar (e como usá-las) e plota no gráfico. Esse mapa normalmente é obtido aplicando a função &lt;code&gt;fortify&lt;/code&gt; em um conjunto de dados geospaciais.&lt;/p&gt;
&lt;p&gt;Para os gráficos que vamos construir aqui, não vai ser necessário aplicar a função &lt;code&gt;fortify&lt;/code&gt;, pois o resultado desse passo já está disponível no pacote &lt;code&gt;abjData&lt;/code&gt; e ele é o data_frame &lt;code&gt;br_uf_map&lt;/code&gt;. Tudo que vamos precisar fazer é pedir que o &lt;code&gt;geom_map&lt;/code&gt; use esse cara.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::install_github(&amp;#39;abjur/abjData&amp;#39;)
#instala o pacote&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;constroi_mapa_tematico &amp;lt;- function(dataset){
  dataset %&amp;gt;% 
  inner_join(abjData::br_uf_map) %&amp;gt;% {
    ggplot(.) +
    geom_map(aes(x = long, y = lat,
                 map_id = id, fill = variavel),
             color = &amp;#39;gray30&amp;#39;, map = ., data = .) + 
    theme_void() +
    coord_equal()
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O &lt;code&gt;input&lt;/code&gt; da função é uma tabela &lt;code&gt;dataset&lt;/code&gt; com duas colunas&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt;, que representa as unidades da federação abreviada;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;variavel&lt;/code&gt;, variável numérica (ou fator) que vai colorir o gráfico.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;No exemplo acima essa tabela era:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dataset %&amp;gt;% 
  head(10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;FALSE # A tibble: 10 × 2
FALSE       id  variavel
FALSE    &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;
FALSE 1     TO  94.93079
FALSE 2     SP 278.79676
FALSE 3     SE  35.50231
FALSE 4     SC 204.85650
FALSE 5     RS 169.19369
FALSE 6     RR 114.90413
FALSE 7     RO 152.47085
FALSE 8     RN  26.22847
FALSE 9     RJ 107.42855
FALSE 10    PR 148.47011&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;os-tweaks&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Os tweaks&lt;/h2&gt;
&lt;p&gt;A função &lt;code&gt;constroi_mapa_tematico&lt;/code&gt; devolve um &lt;code&gt;ggplot2&lt;/code&gt;, então ainda dá pra mexer em alguns parâmetros estéticos após a construção do mapa. As três coisas que vamos aprender a fazer são&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Adicionar labels e títulos&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dataset %&amp;gt;% 
  constroi_mapa_tematico() +
  ggtitle(&amp;quot;Roubos de carros no Brasil em 2014&amp;quot;) +
  scale_fill_continuous(name = &amp;quot;Taxa/100 mil hab.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-05-04-mapas-tematicos-3-minutos_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Alterar as cores da escala&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dataset %&amp;gt;% 
  constroi_mapa_tematico() +
  ggtitle(&amp;quot;Roubos de carros no Brasil em 2014&amp;quot;) +
  scale_fill_continuous(name = &amp;quot;Taxa/100 mil hab.&amp;quot;, low = &amp;#39;white&amp;#39;, high = &amp;#39;red&amp;#39;,
                        na.value = &amp;#39;white&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-05-04-mapas-tematicos-3-minutos_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Alterar valores&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dataset %&amp;gt;% 
  constroi_mapa_tematico() +
  ggtitle(&amp;quot;Roubos de carros no Brasil em 2014&amp;quot;) +
  scale_fill_continuous(name = &amp;quot;Taxa/100 mil hab.&amp;quot;, low = &amp;#39;green&amp;#39;, high = &amp;#39;red&amp;#39;,
                        na.value = &amp;#39;white&amp;#39;, breaks = seq(0,300,50))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-05-04-mapas-tematicos-3-minutos_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>As cores da Marvel vs DC</title>
      <link>http://curso-r.com/blog/2017/05/01/2017-05-01-as-paletas-de-cores-da-marvel-vs-dc/</link>
      <pubDate>Mon, 01 May 2017 23:26:00 +0300</pubDate>
      
      <guid>http://curso-r.com/blog/2017/05/01/2017-05-01-as-paletas-de-cores-da-marvel-vs-dc/</guid>
      <description>&lt;p&gt;A cor é uma diferença notável entre os filmes da Marvel e da DC. Enquanto a Disney/Marvel Studios costuma lançar filmes com tons mais claros e alegres, a Warner tem optado por cenários escuros, com um aspecto mais sombrios. Essas escolhas são um reflexo do clima das histórias de cada universo: aventuras engraçaralhas com um drama superficial vs seja lá o que passa na cabeça do &lt;a href=&#34;http://retalhoclub.com.br/wp-content/uploads/2017/03/03.jpg&#34;&gt;Zack Snyder&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para estudar melhor a paleta de cores utilizadas nos filmes, vamos aplicar a análise introduzida pelo Dani &lt;a href=&#34;http://curso-r.com/blog/2017/04/22/2017-04-21-paleta-de-cores/&#34;&gt;neste post&lt;/a&gt;, com pequenas alterações. Como amostra, selecionei 10 imagens de Batman vs Superman e 10 do Capitão América: guerra civil. Tentando deixar a análise o menos subjetiva possível, escolhi imagens de cenas emblemáticas e dos principais personagens. Abaixo as imagens que peguei de cada filme.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-05-01-as-paletas-de-cores-da-marvel-vs-dc_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-05-01-as-paletas-de-cores-da-marvel-vs-dc_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Seguindo a análise do Dani, vamos utilizar as seguintes bibliotecas para a análise.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(jpeg)
library(tidyverse)
library(glue)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Eu salvei as imagens em arquivos do tipo “bvs_n.jpg” e “cw_n.jpg”, com n variando de 1 a 10. Isso facilitou a leitura desses arquivos. O código abaixo mostra como criar um vetor com o caminho das 10 imagens de cada filme. Se você quiser saber mais sobre a função &lt;code&gt;glue()&lt;/code&gt;, visite &lt;a href=&#34;http://curso-r.com/blog/2017/04/17/2017-04-08-glue/&#34;&gt;este post&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;arquivos_bvs &amp;lt;- glue(&amp;quot;images/bvs_{n}.jpg&amp;quot;, n = 1:10)
arquivos_cw &amp;lt;- glue(&amp;quot;images/cw_{n}.jpg&amp;quot;, n = 1:10)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como vamos trabalhar com mais de uma imagem, eu criei a função &lt;code&gt;ler_imagem()&lt;/code&gt; para ler os arquivos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ler_imagem &amp;lt;- function(caminho) {
  img &amp;lt;- readJPEG(caminho) %&amp;gt;% 
    apply(3, as.numeric)
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos então usar a função &lt;code&gt;map()&lt;/code&gt; para aplicá-la a todos os 10 arquivos. A função &lt;code&gt;reduce(rbind)&lt;/code&gt; transforma as 10 matrizes de pixels em uma matriz só, como se as imagens estivessem coladas uma embaixo da outra.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;img_bvs &amp;lt;- map(arquivos_bvs, ler_imagem) %&amp;gt;% reduce(rbind)
img_cw &amp;lt;- map(arquivos_cw, ler_imagem) %&amp;gt;% reduce(rbind)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Abaixo estão as funções &lt;code&gt;cria_paleta()&lt;/code&gt; e &lt;code&gt;exibir()&lt;/code&gt; do post do Dani. A única diferença aqui é que a função &lt;code&gt;cria_paleta()&lt;/code&gt; já recebe a matriz representando a imagem.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;criar_paleta &amp;lt;- function(img_matrix, num_cores){
  
  km &amp;lt;- kmeans(img_matrix, centers = num_cores)
  
  img_df &amp;lt;- tibble(
    r = img_matrix[,1], 
    g = img_matrix[,2], 
    b = img_matrix[,3],
    cluster = km$cluster
  )
  
  centroides &amp;lt;- img_df %&amp;gt;%
    group_by(cluster) %&amp;gt;%
    summarise_all(mean)

  centroides &amp;lt;- centroides %&amp;gt;%
    mutate(cor = rgb(r, g, b))

  sort(centroides$cor)
}

exibir &amp;lt;- function(x) {
  n &amp;lt;- length(x)
  old &amp;lt;- par(mar = c(0.5, 0.5, 0.5, 0.5))
  on.exit(par(old))
  
  image(1:n, 1, as.matrix(1:n), col = x,
        ylab = &amp;quot;&amp;quot;, xaxt = &amp;quot;n&amp;quot;, yaxt = &amp;quot;n&amp;quot;, bty = &amp;quot;n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assim, basta aplicar essas funções aos objetos &lt;code&gt;img_bvs&lt;/code&gt; e &lt;code&gt;img_cw&lt;/code&gt; para obter as paletas. Primeiro para o Batman vs Superman:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;paleta_bvs &amp;lt;- criar_paleta(img_bvs, 10)
exibir(paleta_bvs)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-05-01-as-paletas-de-cores-da-marvel-vs-dc_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;E agora para o Capitão América:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;paleta_cw &amp;lt;- criar_paleta(img_cw, 10)
exibir(paleta_cw)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-05-01-as-paletas-de-cores-da-marvel-vs-dc_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Observe que o filme da DC tem cores mais escuras e fortes, com vários tons de azul, indicando as cenas noturnas e de chuva. Já a paleta da Marvel apresenta cores mais claras, com vários tons representando o céu pálido das cenas externas.&lt;/p&gt;
&lt;p&gt;Podemos fazer a análise agora para o pôster de cada filme (o que aparece no IMDB):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-05-01-as-paletas-de-cores-da-marvel-vs-dc_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;img_bvs &amp;lt;- ler_imagem(&amp;quot;images/bvs_poster.jpg&amp;quot;)
paleta_bvs &amp;lt;- criar_paleta(img_bvs, 10)
exibir(paleta_bvs)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-05-01-as-paletas-de-cores-da-marvel-vs-dc_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;img_cw &amp;lt;- ler_imagem(&amp;quot;images/cw_poster.jpg&amp;quot;)
paleta_cw &amp;lt;- criar_paleta(img_cw, 10)
exibir(paleta_cw)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-05-01-as-paletas-de-cores-da-marvel-vs-dc_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;768&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Veja que os diferentes tons de azul se repete no pôster do Batman vs Superman. Já o pôster do Capitão América é bem cinzento, com metade da paleta representando &lt;a href=&#34;http://media.melty.com.br/article-6991-ratio265_1020/filme-50-tons-de-cinza-jamie-dornan-christian.jpg&#34;&gt;tons de cinza&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Fica então o desafio de repetir a análise para outros filmes e compartilhar o resultado com a gente. Comentários? Sugestões? Críticas? Mande a sua opinião!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R 3.4 disponível!</title>
      <link>http://curso-r.com/blog/2017/04/24/2017-04-24-r34/</link>
      <pubDate>Mon, 24 Apr 2017 13:07:31 +0200</pubDate>
      
      <guid>http://curso-r.com/blog/2017/04/24/2017-04-24-r34/</guid>
      <description>&lt;p&gt;A versão 3.4 do R (You Stupid Darkness) foi lançada nesse final de semana! A atualização tem foco principal na performance. Principais mudanças:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Agora temos um compilador JIT (Just In Time) como padrão! Isso significa que você não precisará mais usar a função &lt;code&gt;compiler::cmpfun()&lt;/code&gt; para acelerar suas funções na maioria dos casos. Mais sobre isso abaixo.&lt;/li&gt;
&lt;li&gt;O &lt;code&gt;for&lt;/code&gt; ficou mais eficiente. Agora a alocação dinâmica de vetores está mais rápida, diminuindo ainda mais a diferença entre utilizar &lt;code&gt;for&lt;/code&gt; e funcionais como &lt;code&gt;sapply()&lt;/code&gt;, que trabalham com um vetor pré alocado. Mais sobre isso abaixo.&lt;/li&gt;
&lt;li&gt;Otimizações em operações com matrizes. Não vou entrar em detalhes, mas talvez vocês notem algumas melhorias.&lt;/li&gt;
&lt;li&gt;Agora o método padrão para ordenar vetores é &lt;code&gt;radix&lt;/code&gt;, o que pode aumentar a velocidade de ordenações para vetores com mais de mil entradas.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Para uma lista completa de mudanças, &lt;a href=&#34;https://www.r-bloggers.com/r-3-4-0-is-released-with-new-speed-upgrades-and-bug-fixes/&#34;&gt;veja esse post&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:unnamed-chunk-2&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;http://curso-r.com/blog/2017-04-24-r34_files/figure-html/unnamed-chunk-2-1.png&#34; alt=&#34;R mais rápido! Imagem emprestada do time do [Rcpp](https://github.com/RcppCore).&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: R mais rápido! Imagem emprestada do time do &lt;a href=&#34;https://github.com/RcppCore&#34;&gt;Rcpp&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;jit&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Mais sobre o JIT compiler&lt;/h1&gt;
&lt;p&gt;Veja esse exemplo extraído do livro &lt;a href=&#34;https://csgillespie.github.io/efficientR/programming.html&#34;&gt;Efficient R&lt;/a&gt;. Observe a existência de um &lt;code&gt;&amp;lt;bytecode ...&amp;gt;&lt;/code&gt; na parte de baixo de uma das funções. Isso significa que o pacote &lt;code&gt;compiler&lt;/code&gt; converteu essa função em um código que pode ser interpretado mais rápido.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mean_r = function(x) {
  m = 0
  n = length(x)
  for(i in seq_len(n))
    m = m + x[i] / n
  m
}
cmp_mean_r &amp;lt;- compiler::cmpfun(mean_r)

mean_r
## function(x) {
##   m = 0
##   n = length(x)
##   for(i in seq_len(n))
##     m = m + x[i] / n
##   m
## }
cmp_mean_r
## function(x) {
##   m = 0
##   n = length(x)
##   for(i in seq_len(n))
##     m = m + x[i] / n
##   m
## }
## &amp;lt;bytecode: 0x4c6e430&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para mostrar a mudança, vamos comparar o desempenho das funções usando &lt;code&gt;microbenchmark()&lt;/code&gt;. Essa função calcula o tempo de execução de uma expressão cem vezes e calcula estatísticas básicas dos tempos obtidos.&lt;/p&gt;
&lt;p&gt;No meu servidor, que ainda está com o R 3.3.2, o resultado foi esse. Observe que o tempo da função compilada é quase dez vezes o tempo da função sem compilar.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1)
x &amp;lt;- rnorm(5000)
microbenchmark::microbenchmark(mean_r(x), cmp_mean_r(x), mean(x))
# Unit: microseconds
#           expr      min       lq       mean    median        uq      max neval
#      mean_r(x) 1931.835 2010.295 2302.82298 2102.5995 2357.6715 6186.706   100
#  cmp_mean_r(x)  308.847  311.045  333.26221  314.8935  334.7330  569.117   100
#        mean(x)   14.593   15.443   19.94897   19.0410   21.0405   51.375   100&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No meu computador com o R 3.4, o resultado foi esse. Agora, a diferença entre a função sem compilar e compilada é praticamente impoerceptível. Esse é o efeito do JIT compiler.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1)
x &amp;lt;- rnorm(5000)
microbenchmark::microbenchmark(mean_r(x), cmp_mean_r(x), mean(x))
# Unit: microseconds
#           expr     min       lq     mean   median       uq     max neval
#      mean_r(x) 332.322 332.7220 336.2287 333.0125 334.3785 395.954   100
#  cmp_mean_r(x) 332.305 332.7345 337.0889 333.1460 337.0930 381.306   100
#        mean(x)  13.807  14.0960  14.7349  14.3060  14.5540  30.313   100&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;for&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Mais sobre o for&lt;/h1&gt;
&lt;p&gt;Veja esse código que calcula a média de mil valores em 100 entradas de uma lista.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1)
input &amp;lt;- lapply(1:100, function(x) runif(1000))

mean_for &amp;lt;- function(x) {
  vet &amp;lt;- c()
  for(i in seq_along(x)) {
    vet[i] &amp;lt;- mean(x[[i]])
  }
}
mean_sapply &amp;lt;- function(x) {
  sapply(x, mean)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No meu servidor, que ainda está com o R 3.3.2, o resultado foi esse. Veja como o desempenho do &lt;code&gt;for&lt;/code&gt; é assustadoramente inferior.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;microbenchmark::microbenchmark(mean_for(x), mean_sapply(x))
# Unit: milliseconds
#            expr      min       lq     mean   median       uq      max neval
#     mean_for(x) 41.28675 43.22318 47.39574 44.02713 45.59184 84.80818   100
#  mean_sapply(x) 14.78590 15.46421 16.36619 16.23018 17.28495 19.70854   100&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No meu computador com o R 3.4, o resultado foi esse. Agora o &lt;code&gt;for&lt;/code&gt; está praticamente empatado!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;microbenchmark::microbenchmark(mean_for(x), mean_sapply(x))
# Unit: milliseconds
#            expr      min       lq     mean   median       uq      max neval
#     mean_for(x) 15.16583 15.45924 16.71064 16.14545 17.51002 25.61860   100
#  mean_sapply(x) 14.43704 14.90485 16.20864 15.53319 16.56801 27.36536   100 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mas cuidado! o &lt;code&gt;for&lt;/code&gt; continua sendo uma ideia ruim no R, não só por desempenho, mas por questões de &lt;em&gt;design&lt;/em&gt;. Utilizar funcionais ajuda na performance do computador e torna a vida do cientista de dados mais fácil (veja &lt;a href=&#34;http://curso-r.com/blog/2017/04/10/2017-04-08-progress/&#34;&gt;esse&lt;/a&gt; e &lt;a href=&#34;http://curso-r.com/blog/2017/03/19/2017-03-14-parallel/&#34;&gt;esse&lt;/a&gt; posts que discutem um pouco sobre isso.)&lt;/p&gt;
&lt;div id=&#34;instalacao&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Instalação&lt;/h2&gt;
&lt;p&gt;Se você usa Windows, uma dica é usar o pacote &lt;code&gt;installr&lt;/code&gt;. Basta rodar isso aqui e ser feliz:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(&amp;quot;installr&amp;quot;)
installr::updateR()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;É isso! Happy coding ;)&lt;/p&gt;
&lt;p&gt;OBS: Se você ficou curiosa sobre o nome da versão, encontrei essa tirinha de 1965 do Peanuts. Acho que foi isso que deu origem ao nome!&lt;/p&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:unnamed-chunk-10&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;http://curso-r.com/blog/2017-04-24-r34_files/figure-html/unnamed-chunk-10-1.png&#34; alt=&#34;You Stupid Darknes! http://www.gocomics.com/peanuts/1965/09/09.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 2: You Stupid Darknes! &lt;a href=&#34;http://www.gocomics.com/peanuts/1965/09/09&#34; class=&#34;uri&#34;&gt;http://www.gocomics.com/peanuts/1965/09/09&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>K-means e paleta de cores</title>
      <link>http://curso-r.com/blog/2017/04/22/2017-04-21-paleta-de-cores/</link>
      <pubDate>Sat, 22 Apr 2017 13:07:31 +0200</pubDate>
      
      <guid>http://curso-r.com/blog/2017/04/22/2017-04-21-paleta-de-cores/</guid>
      <description>&lt;p&gt;Uma aplicação interessante de algoritmos de clusterização é a obtenção de paletas de cores a partir de imagens. Veja como isso pode ser feito usando o R.&lt;/p&gt;
&lt;p&gt;Em primeiro lugar, vamos ler a imagem como uma matriz para o R. Existem diversas bibliotecas para carregar as imagens, vamos usar aqui a &lt;a href=&#34;https://CRAN.R-project.org/package=jpeg&#34;&gt;&lt;code&gt;jpeg&lt;/code&gt;&lt;/a&gt;. Para esse caso ela é melhor porque já lê a imagem no formato que precisamos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(jpeg)
library(magrittr)
img &amp;lt;- readJPEG(&amp;quot;img/david-bowie.jpg&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A imagem lida pelo pacote &lt;code&gt;jpeg&lt;/code&gt; é representada por um &lt;code&gt;array&lt;/code&gt; com dimensões: &lt;code&gt;c(altura, largura, n_bandas)&lt;/code&gt; que no nosso caso é &lt;code&gt;c(1100, 727, 3)&lt;/code&gt;. O número de bandas é 3: R, G e B.&lt;/p&gt;
&lt;p&gt;Podemos exibir a imagem no R, convertendo o array, primeiro em um obheto do tipo &lt;code&gt;raster&lt;/code&gt; e depois simplesmente usando a função &lt;code&gt;plot&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(as.raster(img))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-04-21-paleta-de-cores_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;1536&#34; /&gt;&lt;/p&gt;
&lt;p&gt;O problema de obter a paleta de cores de uma imagem pode ser formulado como um problema de clusterização: “obter grupos de individuos que possuem a menor diferença dentro de cada um e a maior diferença possível entre os grupos de acordo com algumas características das unidades amostrais”.&lt;/p&gt;
&lt;p&gt;Nesse caso, os indivíduos são os pixels da imagem e as características que estamos interessados são os valores de R, de G e de B (valores que representam a cor do pixel). Para o algortimos de clusterização, precisamos de uma matriz com as 3 colunas R, G e B e largura*altura (numero de pixels) linhas representado os indivíduos. É exatamente essa conversão que o trecho de código a seguir realiza.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;img_matrix &amp;lt;- apply(img, 3, as.numeric)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora temos uma matriz com 3 colunas e 799.700 linhas. Vamos aplicar agora o algoritmo k-means, para organizar cada um desses pixels em um grupo. O K-means pede o número de grupos como input, vamos começar com 6.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;km &amp;lt;- kmeans(img_matrix, centers = 6)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O objeto gerado pela função &lt;code&gt;kmeans&lt;/code&gt; armazena um vetor chamado &lt;code&gt;cluster&lt;/code&gt; (do tamanho do número de linhas da matriz) com um identificador do grupo de cada observação da matriz.&lt;/p&gt;
&lt;p&gt;A cor que representa cada um dos grupos é representada pelo vetor c(r, g, b) com a média de todas as observações de cada um dos grupos. Podemos obter isso com algumas manipulações usando o &lt;code&gt;dplyr&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tibble)
library(dplyr)
## 
## Attaching package: &amp;#39;dplyr&amp;#39;
## The following objects are masked from &amp;#39;package:stats&amp;#39;:
## 
##     filter, lag
## The following objects are masked from &amp;#39;package:base&amp;#39;:
## 
##     intersect, setdiff, setequal, union
img_df &amp;lt;- tibble(
  r = img_matrix[,1], 
  g = img_matrix[,2], 
  b = img_matrix[,3],
  cluster = km$cluster
  )
centroides &amp;lt;- img_df %&amp;gt;%
  group_by(cluster) %&amp;gt;%
  summarise_all(mean)

centroides
## # A tibble: 6 × 4
##   cluster         r          g         b
##     &amp;lt;int&amp;gt;     &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
## 1       1 0.5005264 0.18317492 0.1587960
## 2       2 0.1242676 0.04329523 0.2157608
## 3       3 0.2212878 0.27343708 0.4408806
## 4       4 0.7016494 0.46722267 0.3238223
## 5       5 0.3541964 0.46238302 0.5494433
## 6       6 0.8768120 0.76211694 0.6453261&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Também transformamos uma cor r, g e b em uma representação hexadecimal. Assim conseguimos um vetor de caracteres que representa a a paleta de cores.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;centroides &amp;lt;- centroides %&amp;gt;%
  mutate(cor = rgb(r, g, b))
centroides$cor
## [1] &amp;quot;#802F28&amp;quot; &amp;quot;#200B37&amp;quot; &amp;quot;#384670&amp;quot; &amp;quot;#B37753&amp;quot; &amp;quot;#5A768C&amp;quot; &amp;quot;#E0C2A5&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para exibir a paleta vamos usar a seguinte função que foi copiada e levemente modificada &lt;a href=&#34;https://github.com/karthik/wesanderson&#34;&gt;daqui&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;exibir &amp;lt;- function(x) {
  n &amp;lt;- length(x)
  old &amp;lt;- par(mar = c(0.5, 0.5, 0.5, 0.5))
  on.exit(par(old))

  image(1:n, 1, as.matrix(1:n), col = x,
        ylab = &amp;quot;&amp;quot;, xaxt = &amp;quot;n&amp;quot;, yaxt = &amp;quot;n&amp;quot;, bty = &amp;quot;n&amp;quot;)
}
exibir(sort(centroides$cor))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-04-21-paleta-de-cores_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Assim obtivemos uma paleta de cores da imagem que mostramos anteriormente. Vamos colocar todo o código que fizemos passo a passo aqui em uma única função para podermos facilmente criar a paleta de cores para outras imagens.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;criar_paleta &amp;lt;- function(img, num_cores){
  # transforma a imagem em uma matriz
  img_matrix &amp;lt;- apply(img, 3, as.numeric)
  # treina o algoritmo de k médias
  km &amp;lt;- kmeans(img_matrix, centers = num_cores)
  img_df &amp;lt;- tibble(
    r = img_matrix[,1], 
    g = img_matrix[,2], 
    b = img_matrix[,3],
    cluster = km$cluster
  )
  # calcula os centroides dos grupos
  centroides &amp;lt;- img_df %&amp;gt;%
    group_by(cluster) %&amp;gt;%
    summarise_all(mean)
  # transforma a cor em hexadecimal
  centroides &amp;lt;- centroides %&amp;gt;%
    mutate(cor = rgb(r, g, b))
  # vetor de cores
  sort(centroides$cor)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vejamos agora o que acontece com essa bela imagem do filme Moonrise Kingdom do Wes Anderson, que é famoso por fazer filmes com belas paletas de cores.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;moonrise &amp;lt;- readJPEG(&amp;quot;img/moonrise-kingdom.jpg&amp;quot;)
plot(as.raster(moonrise))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-04-21-paleta-de-cores_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;1536&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;paleta &amp;lt;- criar_paleta(moonrise, 6)
exibir(paleta)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://curso-r.com/blog/2017-04-21-paleta-de-cores_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;É isso. Se você gostou, tente fazer com outras imagens e compartilhe com a gente os resultados.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>